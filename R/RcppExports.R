# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' The MLLR_1 distribution
#'
#' Quantile function, distribution function, and random generation for the MLLR_1 distribution family. See Park (2023) for information about the MLLR distributions.
#'
#' @name MLLR1
#' @param p vector of probabilities
#' @param q vector of quantiles
#' @param n number of draws
#' @param M the first parameter for the MLLR_1 distributions
#' @param k the second parameter for the MLLR_1 distribution
#' @param precision The requested level of precision for the outputs of qmllr1 and pmllr1 functions, in terms of the estimated standard deviation of the output. For example precision of 0.01 will output values with the standard deviation of approximately equal to 0.01.
#' @param lower logical; if TRUE, probabilities are P[X <= x], otherwise, P[X > x].
#' @param log_p logical; if TRUE, probabilities p are given as log(p).
#' @param force logical; if TRUE, the function will run regardless of how long it will take. If FALSE, the function will ask if you want to continue, stop, or give a new precision value whenever the expected run time is longer than 15 seconds. 
#' @return a list consisting of the numeric vector of quantiles and the precision (numeric) used.
#' @examples
#' qmllr1(.99, 5, 2)
#' qmllr1(c(.01, .05, .95, .99), 10, 2.3)
#' qmllr1(c(.01, .05, .95, .99), 10, 2.3, precision=0.01, lower=TRUE)
#' pmllr1(c(-8.3, -5.9), 8, 1)
#' pmllr1(c(-8.3, -5.9), 8 ,1, force=TRUE)
#' rmllr1(10, 7, 2)
#' @export
qmllr1 <- function(p, M, k, precision = 0.01, lower = TRUE, log_p = FALSE, force = FALSE) {
    .Call(`_siblle_qmllr1`, p, M, k, precision, lower, log_p, force)
}

#' @rdname MLLR1
pmllr1 <- function(q, M, k, precision = 0.01, lower = TRUE, log_p = FALSE, force = FALSE) {
    .Call(`_siblle_pmllr1`, q, M, k, precision, lower, log_p, force)
}

#' @rdname MLLR1
rmllr1 <- function(n, M, k) {
    .Call(`_siblle_rmllr1`, n, M, k)
}

#' The MLLR_2 distribution
#'
#' Quantile function, distribution function, and random generation for the MLLR_2 distribution family. See Park (2023) for information about the MLLR distributions.
#'
#' @name MLLR2
#' @param p vector of probabilities
#' @param q vector of quantiles
#' @param n number of draws
#' @param M the first parameter for the MLLR_2 distribution
#' @param k the second parameter for the MLLR_2 distribution
#' @param precision The requested level of precision for the outputs of qmllr2 and pmllr2 functions, in terms of the estimated standard deviation of the output. For example precision of 0.01 will output values with the standard deviation of approximately equal to 0.01.
#' @param lower logical; if TRUE, probabilities are P[X <= x], otherwise, P[X > x].
#' @param log_p logical; if TRUE, probabilities p are given as log(p).
#' @param force logical; if TRUE, the function will run regardless of how long it will take. If FALSE, the function will ask if you want to continue, stop, or give a new precision value whenever the expected run time is longer than 15 seconds. 
#' @return a list consisting of the numeric vector of quantiles and the precision (numeric) used.
#' @examples
#' qmllr2(.99, 5, 2, 1.2, 0.23)
#' qmllr2(c(.01, .05, .95, .99), 10, 2.3, 3, 10)
#' qmllr2(c(.01, .05, .95, .99), 10, 2.3, 3, 10, precision=0.01, lower=TRUE)
#' pmllr2(c(-8.3, -5.9), 8, 1, 3.8, 4.1)
#' pmllr2(c(-8.3, -5.9), 8 ,1, 3.8, 4.1, force=TRUE)
#' rmllr2(10, 7, 2, 91, 1.1)
#' @export
qmllr2 <- function(p, M, k, nu, s0, precision = 0.01, lower = TRUE, log_p = FALSE, force = FALSE) {
    .Call(`_siblle_qmllr2`, p, M, k, nu, s0, precision, lower, log_p, force)
}

#' @rdname MLLR2
pmllr2 <- function(q, M, k, nu, s0, precision = 0.01, lower = TRUE, log_p = FALSE, force = FALSE) {
    .Call(`_siblle_pmllr2`, q, M, k, nu, s0, precision, lower, log_p, force)
}

#' @rdname MLLR2
rmllr2 <- function(n, M, k, nu, s0) {
    .Call(`_siblle_rmllr2`, n, M, k, nu, s0)
}

